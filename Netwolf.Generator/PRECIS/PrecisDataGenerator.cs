// Copyright (c) 2025 Ryan Schmidt <skizzerz@skizzerz.net>
// SPDX-License-Identifier: LGPL-3.0-or-later

using Microsoft.CodeAnalysis;

using Netwolf.Generator.Internal;

using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;

namespace Netwolf.Generator.PRECIS;

[Generator]
public class PrecisDataGenerator : IIncrementalGenerator
{
    private static readonly Regex DecompositionFieldRegex = new(@"^<([^>]+)> (.+)$");

    /// <summary>
    /// Properties that are extracted from the PropList.txt and DerivedCoreProperties.txt files.
    /// </summary>
    private static readonly HashSet<string> ExtractedProperties = [
        "Join_Control",
        "Noncharacter_Code_Point",
        "Default_Ignorable_Code_Point",
    ];

    public static StringBuilder GetDecompositionSourceText(ImmutableArray<DecompositionMapping?> mappings)
    {
        var sb = new StringBuilder();

        sb.Append(@"// <auto-generated/>
namespace Netwolf.PRECIS.Internal
{
    internal static partial class DecompositionMappings
    {
        private static partial IEnumerable<KeyValuePair<int, int[]>> GetWideMappings()
        {
");

        foreach (var item in mappings.Where(m => m != null && m.Class == "wide"))
        {
            var ints = item!.To.Select(i => $"0x{i:X4}");
            sb.AppendLine($"            yield return new(0x{item.From:X4}, [{string.Join(", ", ints)}]);");
        }

        sb.Append(@"
        }

        private static partial IEnumerable<KeyValuePair<int, int[]>> GetNarrowMappings()
        {
");

        foreach (var item in mappings.Where(m => m != null && m.Class == "narrow"))
        {
            var ints = item!.To.Select(i => $"0x{i:X4}");
            sb.AppendLine($"            yield return new(0x{item.From:X4}, [{string.Join(", ", ints)}]);");
        }

        sb.Append(@"
        }
    }
}");

        return sb;
    }

    public static StringBuilder GetBidiSourceText(ImmutableArray<(bool, Lookup)> bidi)
    {
        var bidiClasses = bidi
            .Where(static tup => tup.Item1 == false)
            .Select(static tup => tup.Item2)
            .OrderBy(static lookup => lookup.From)
            .ToList();

        var bidiFallbacks = bidi
            .Where(static tup => tup.Item1 == true && tup.Item2.From != 0)
            .Select(static tup => tup.Item2)
            .OrderBy(static lookup => lookup.From)
            .ToList();

        var sb = new StringBuilder();
        sb.Append(@"// <auto-generated/>
using System.Text;

namespace Netwolf.PRECIS.Internal
{
    internal static partial class UnicodeProperty
    {
        internal static partial BidiClass GetBidiClass(Rune rune)
        {
            return GeneratedDatabaseLookup<BidiClass>(rune.Value, GeneratedBidiClasses) ??
                   GeneratedDatabaseLookup<BidiClass>(rune.Value, GeneratedBidiFallbacks) ??
                   BidiClass.LeftToRight;
        }

        private static readonly List<Tuple<int, int, BidiClass>> GeneratedBidiClasses = new()
        {
");

        foreach (var lookup in bidiClasses)
        {
            sb.AppendLine($"            new Tuple<int, int, BidiClass>(0x{lookup.From:X4}, 0x{lookup.To:X4}, BidiClass.{lookup.Class.Replace("_", string.Empty)}),");
        }

        sb.Append(@"
        };

        private static readonly List<Tuple<int, int, BidiClass>> GeneratedBidiFallbacks = new()
        {
");

        foreach (var lookup in bidiFallbacks)
        {
            sb.AppendLine($"            new Tuple<int, int, BidiClass>(0x{lookup.From:X4}, 0x{lookup.To:X4}, BidiClass.{lookup.Class.Replace("_", string.Empty)}),");
        }

        sb.Append(@"
        };
    }
}");

        return sb;
    }

    public static StringBuilder GetPropSourceText(ImmutableArray<Lookup> props)
    {
        var propNames = props.Select(p => p.Class).Distinct().OrderBy(pn => pn).ToList();

        var sb = new StringBuilder();
        sb.Append(@"// <auto-generated/>
using System.Text;

namespace Netwolf.PRECIS.Internal
{
    internal static partial class UnicodeProperty
    {
");

        foreach (var prop in propNames)
        {
            sb.Append(@$"        internal static partial bool Is{prop.Replace("_", string.Empty)}(Rune rune) => rune.Value switch
        {{
");

            foreach (var lookup in props.Where(p => p.Class == prop))
            {
                if (lookup.From == lookup.To)
                {
                    sb.AppendLine($"            0x{lookup.From:X4} => true,");
                }
                else
                {
                    sb.AppendLine($"            >= 0x{lookup.From:X4} and <= 0x{lookup.To:X4} => true,");
                }
            }

            sb.Append(@"            _ => false
        };
");
        }

        sb.Append(@"
    }
}");

        return sb;
    }

    public static StringBuilder GetGenericLookupSourceText(IEnumerable<Lookup> data, string enumType, string defaultValue)
    {
        var sortedData = data
            .OrderBy(static lookup => lookup.From)
            .ToList();

        var sb = new StringBuilder();
        sb.Append($@"// <auto-generated/>
using System.Text;

namespace Netwolf.PRECIS.Internal
{{
    internal static partial class UnicodeProperty
    {{
        internal static partial {enumType} Get{enumType}(Rune rune)
        {{
            return GeneratedDatabaseLookup<{enumType}>(rune.Value, Generated{enumType}) ??
                   {enumType}.{defaultValue};
        }}

        private static readonly List<Tuple<int, int, {enumType}>> Generated{enumType} = new()
        {{
");

        foreach (var lookup in sortedData)
        {
            sb.AppendLine($"            new Tuple<int, int, {enumType}>(0x{lookup.From:X4}, 0x{lookup.To:X4}, {enumType}.{lookup.Class.Replace("_", string.Empty)}),");
        }

        sb.Append(@"
        };
    }
}");

        return sb;
    }

    public static StringBuilder GetCombiningSourceText(ImmutableArray<Lookup> data)
    {
        var combiningClasses = data
            .Where(static lookup => lookup.Class != "0")
            .OrderBy(static lookup => lookup.From)
            .ToList();

        var sb = new StringBuilder();
        sb.Append(@"// <auto-generated/>
using System.Text;

namespace Netwolf.PRECIS.Internal
{
    internal static partial class UnicodeProperty
    {
        internal static partial CombiningClass GetCombiningClass(Rune rune)
        {
            return (CombiningClass)(GeneratedDatabaseLookup<int>(rune.Value, GeneratedCombiningClasses) ?? 0);
        }

        private static readonly List<Tuple<int, int, int>> GeneratedCombiningClasses = new()
        {
");

        foreach (var lookup in combiningClasses)
        {
            sb.AppendLine($"            new Tuple<int, int, int>(0x{lookup.From:X4}, 0x{lookup.To:X4}, {lookup.Class}),");
        }

        sb.Append(@"
        };
    }
}");

        return sb;
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assembly = context.CompilationProvider
            .Select(static (compilation, _) => compilation.AssemblyName);

        var data = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("UnicodeData.txt"))
            // Don't read any files unless we're in the correct assembly
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            // Extract all lines from the file
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            // Extract the mapping field from each line
            .Select(static (line, token) => ExtractDecompositionField(line, token))
            .Where(static mapping => mapping != null && (mapping.Class == "wide" || mapping.Class == "narrow"))
            // Convert to a single value provider containing an enumerable
            .Collect();

        var bidi = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("DerivedBidiClass.txt"))
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            .Where(static line => !string.IsNullOrEmpty(line) && (!line.StartsWith("#") || line.StartsWith("# @missing:")))
            .Select(static (line, token) => (line.StartsWith("#"), ExtractLookup(line, token)))
            .Collect();

        var props = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("PropList.txt") || text.Path.EndsWith("DerivedCoreProperties.txt"))
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            .Where(static line => !string.IsNullOrEmpty(line) && !line.StartsWith("#"))
            .Select(static (line, token) => ExtractLookup(line, token))
            .Where(static lookup => ExtractedProperties.Contains(lookup.Class))
            .Collect();

        var hangul = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("HangulSyllableType.txt"))
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            .Where(static line => !string.IsNullOrEmpty(line) && !line.StartsWith("#"))
            .Select(static (line, token) => ExtractLookup(line, token))
            .Collect();

        var combining = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("DerivedCombiningClass.txt"))
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            .Where(static line => !string.IsNullOrEmpty(line) && !line.StartsWith("#"))
            .Select(static (line, token) => ExtractLookup(line, token))
            .Collect();

        var joining = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("DerivedJoiningType.txt"))
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            .Where(static line => !string.IsNullOrEmpty(line) && !line.StartsWith("#"))
            .Select(static (line, token) => ExtractLookup(line, token))
            .Collect();

        var scripts = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith("Scripts.txt"))
            .Combine(assembly)
            .Where(static model => model.Right == "Netwolf.PRECIS")
            .SelectMany(static (model, token) => model.Left.GetText(token)?.ToString().Split('\n') ?? [])
            .Where(static line => !string.IsNullOrEmpty(line) && !line.StartsWith("#"))
            .Select(static (line, token) => ExtractLookup(line, token))
            .Collect();

        context.RegisterSourceOutput(data, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("DecompositionMappings.g.cs", GetDecompositionSourceText(model).ToString());
            }
        });

        context.RegisterSourceOutput(bidi, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("UnicodeProperty.BidiClass.g.cs", GetBidiSourceText(model).ToString());
            }
        });

        context.RegisterSourceOutput(props, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("UnicodeProperty.PropList.g.cs", GetPropSourceText(model).ToString());
            }
        });

        context.RegisterSourceOutput(hangul, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("UnicodeProperty.HangulSyllableType.g.cs",
                    GetGenericLookupSourceText(model, "HangulSyllableType", "NotApplicable").ToString());
            }
        });

        context.RegisterSourceOutput(combining, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("UnicodeProperty.CombiningClass.g.cs", GetCombiningSourceText(model).ToString());
            }
        });

        context.RegisterSourceOutput(joining, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("UnicodeProperty.JoiningType.g.cs",
                    GetGenericLookupSourceText(model, "JoiningType", "NonJoining").ToString());
            }
        });

        context.RegisterSourceOutput(scripts, static (sourceProductionContext, model) =>
        {
            if (!model.IsEmpty)
            {
                sourceProductionContext.AddSource("UnicodeProperty.Scripts.g.cs",
                    GetGenericLookupSourceText(model, "Script", "Unknown").ToString());
            }
        });
    }

    private static DecompositionMapping? ExtractDecompositionField(string line, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#"))
        {
            // skip empty lines and comments
            return null;
        }

        // decomposition mapping is the 6th field
        var fields = line.Split(';');
        if (fields.Length < 6 || string.IsNullOrEmpty(fields[5]))
        {
            return null;
        }

        // field is of the form "<class> mapping"
        var match = DecompositionFieldRegex.Match(fields[5]);
        if (!match.Success)
        {
            return null;
        }

        var className = match.Groups[1].Value;
        var from = Convert.ToInt32(fields[0], 16);
        var mappings = match.Groups[2].Value.Split(' ').Select(m => Convert.ToInt32(m, 16)).ToImmutableArray();

        return new(className, from, mappings);
    }

    private static Lookup ExtractLookup(string line, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        if (line.StartsWith("# @missing:"))
        {
            line = line.Substring(11);
        }
        else
        {
            line = line.Substring(0, line.IndexOf('#'));
        }

        string[] data = line.Split(';');
        if (data[0].IndexOf('.') != -1)
        {
            // have a range
            string[] range = data[0].Split(['.'], StringSplitOptions.RemoveEmptyEntries);
            return new(Convert.ToInt32(range[0].Trim(), 16), Convert.ToInt32(range[1].Trim(), 16), data[1].Trim());
        }
        else
        {
            // no range
            return new(Convert.ToInt32(data[0].Trim(), 16), Convert.ToInt32(data[0].Trim(), 16), data[1].Trim());
        }
    }
}
