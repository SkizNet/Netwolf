// Copyright (c) 2024 Ryan Schmidt <skizzerz@skizzerz.net>
// SPDX-License-Identifier: CC0-1.0 OR LGPL-3.0-or-later

using System.Text;

namespace Netwolf.Generator.PluginFramework;

internal static class SourceGeneratedCommandSkeleton
{
    internal static string GenerateThunkFile(CommandContext command, CommandAttributeContext attr, string resultType)
    {
        StringBuilder sb = new();
        List<string> paramNames = [];
        string generatedTypeName = $"NetwolfCommandThunk_{attr.Name}_{command.ContainerType.Replace('.', '_')}_{command.MethodName}";

        string paramTypes = string.Join(", ",
            command.Parameters.Select(p => "typeof(" + p.ParameterType + (p.Classification == ParameterClassification.Array ? "[])" : ")")));

        // generated file is in null-oblivious context because we don't know the setting the user chose for the compilation
        // and we don't want to cause any null warnings from generated code. Easier to just be oblivious.
        sb.Append($@"// <auto-generated />

#nullable disable
#pragma warning disable CS0219
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Reflection;

using Netwolf.Attributes;
using Netwolf.PluginFramework.Commands;
using Netwolf.PluginFramework.Context;
using Netwolf.PluginFramework.Util;

[assembly: SourceGeneratedCommand(typeof({command.ContainerType}), typeof(Netwolf.Generated.{generatedTypeName}), typeof({resultType}))]

namespace Netwolf.Generated;

public sealed class {generatedTypeName} : ICommandHandler<{resultType}>
{{
    string ICommandHandler.Command => {attr.NameSyntax};
    string ICommandHandler.Privilege => {attr.PrivilegeSyntax};

    public{(command.IsMethodAsync ? " async" : "")} Task<{resultType}> ExecuteAsync(ICommand command, IContext sender, CancellationToken cancellationToken)
    {{
        cancellationToken.ThrowIfCancellationRequested();

        ICommandEnumerator enumerator = command.CommandType switch
        {{
            CommandType.Bot => new CommandStringEnumerator(command.Args.FirstOrDefault()),
            _ => new CommandArgsEnumerator(command.Args)
        }};

        var haveArg = enumerator.MoveNext();
        bool success = false;
        var paramInfos = typeof({command.ContainerType})
            .GetMethod(""{command.MethodName}"", new Type[] {{ {paramTypes} }})
            .GetParameters()
            .ToList();
");

        // parse incoming parameters
        for (int i = 0; i < command.Parameters.Count; i++)
        {
            var param = command.Parameters[i];
            var paramName = $"p{i}";
            paramNames.Add(paramName);

            // check for well-known things
            if (param.Classification == ParameterClassification.IContext)
            {
                sb.AppendLine($"        var {paramName} = sender;");
            }
            else if (param.Classification == ParameterClassification.CancellationToken)
            {
                sb.AppendLine($"        var {paramName} = cancellationToken;");
            }
            else if (param.Classification == ParameterClassification.CommandName)
            {
                sb.AppendLine($"        var {paramName} = {string.Format(param.ConversionTemplate, attr.Name)};");
            }
            else if (param.Classification == ParameterClassification.Rest)
            {
                sb.AppendLine($"        var {paramName} = {string.Format(param.ConversionTemplate, "haveArg ? enumerator.Rest : string.Empty")};");
                sb.AppendLine($"        enumerator.MoveToEnd();");
                sb.AppendLine($"        haveArg = false;");
            }
            else if (param.Classification == ParameterClassification.Array)
            {
                sb.Append($@"        List<{param.ParameterType}> {paramName}_builder = [];
        while (haveArg && success)
        {{
            var value = {string.Format(param.ConversionTemplate, "enumerator.Current")};
            {(param.ConversionTemplate == "{0}" ? "success = true;" : string.Empty)}
            if (success)
            {{
                {paramName}_builder.Add(value);
                haveArg = enumerator.MoveNext();
            }}
        }}
        var {paramName} = {paramName}_builder.ToArray();
");
            }
            else
            {
                // ParameterClassification.Scalar
                sb.AppendLine($"        var {paramName} = {string.Format(param.ConversionTemplate, "haveArg ? enumerator.Current : null")};");
                sb.AppendLine($"        {(param.ConversionTemplate != "{0}" ? "if (success) " : string.Empty)}haveArg = enumerator.MoveNext();");
            }

            sb.Append($@"        var validationContext = sender.ValidationContextFactory?.Create(paramInfos[{i}]) ?? new ValidationContext(paramInfos[{i}]);
            validationContext.MemberName = paramInfos[{i}].Name;
            validationContext.DisplayName = paramInfos[{i}].GetCustomAttribute<DisplayAttribute>()?.GetName() ?? paramInfos[{i}].Name ?? ""_{i}"";

            // throws ValidationException on validation failure
            Validator.ValidateValue({paramName}, validationContext, paramInfos[{i}].GetCustomAttributes<ValidationAttribute>());
");
        }

        // run the command; we always populate the result variable to simplify later logic
        sb.Append("        ");
        if (!command.IsMethodVoid)
        {
            sb.Append("var result = ");
        }
        else
        {
            sb.AppendLine("object result = null;");
        }

        if (command.IsMethodAsync)
        {
            sb.Append("await ");
        }

        sb.Append($"(({command.ContainerType})sender.Sender).{command.MethodName}(");
        sb.Append(string.Join(", ", paramNames));
        sb.AppendLine(");");

        // return an appropriate value
        if (command.IsMethodAsync)
        {
            sb.AppendLine($"        return new {resultType}(result);");
        }
        else
        {
            sb.AppendLine($"        return Task.FromResult(new {resultType}(result));");
        }

            sb.Append(@"
    }
}
");

        return sb.ToString();
    }
}
