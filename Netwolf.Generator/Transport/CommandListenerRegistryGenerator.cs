// Copyright (c) 2024 Ryan Schmidt <skizzerz@skizzerz.net>
// SPDX-License-Identifier: LGPL-3.0-or-later

using Microsoft.CodeAnalysis;

using Netwolf.Generator.Internal;

using System.Text;

namespace Netwolf.Generator.Transport;

[Generator]
public class CommandListenerRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assembly = context.CompilationProvider.Select(static (compilation, _) => compilation.AssemblyName);
        var attributes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Netwolf.Transport.Internal.CommandListenerAttribute",
            static (_, _) => true,
            static (context, _) => context.TargetSymbol.ToFullyQualifiedString());

        context.RegisterSourceOutput(attributes.Collect().Combine(assembly), static (sourceProductionContext, model) =>
        {
            // only execute in Netwolf.Transport
            if (model.Right != "Netwolf.Transport")
            {
                return;
            }

            sourceProductionContext.AddSource("CommandListenerRegistry.g.cs", GetSourceText(model.Left).ToString());
        });
    }

    private static StringBuilder GetSourceText(IReadOnlyCollection<string> listenerTypes)
    {
        var sb = new StringBuilder();
        sb.Append(@"// <auto-generated/>
namespace Netwolf.Transport.Internal
{
    internal partial class CommandListenerRegistry
    {
        private static partial IEnumerable<Type> GetCommandListenerTypes()
        {
");

        foreach (var type in listenerTypes)
        {
            sb.AppendLine($"            yield return typeof({type});");
        }

        // don't error out if there aren't any listener types
        if (listenerTypes.Count == 0)
        {
            sb.AppendLine("            yield break;");
        }

        sb.Append(@"
        }
    }
}");

        return sb;
    }
}
